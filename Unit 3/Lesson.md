# Module 3: MongoDB Data Modeling

## Table of Contents
1. Collections and Documents data model
2. BSON format and data types
3. Schema design principles and best practices
4. Embedded documents vs. referencing
5. One-to-one, one-to-many, and many-to-many relationships




## Collections and Documents data model

In MongoDB, data is organized and stored in collections and documents. Collections are similar to tables in relational databases, as they serve as containers for related data. Each collection can contain multiple documents, which are comparable to records or rows in relational databases.

The concept of collections and documents can be understood through an example. Let's consider a bookstore application. In a relational database, you might have a "Books" table where each row represents a book with columns for attributes like title, author, and ISBN. In MongoDB, you would create a collection called "Books" to store these books. Each individual book would be represented as a document within the "Books" collection.

Here's an example of a document in the "Books" collection in MongoDB:

```javascript
{
  "_id": ObjectId("60eae773eae9f94db6a69cf4"),
  "title": "The Great Gatsby",
  "author": "F. Scott Fitzgerald",
  "isbn": "978-0-684-80146-3",
  "price": 10.99
}
```

In this example, each field in the document represents an attribute of the book, such as title, author, ISBN, and price. The `_id` field is a unique identifier automatically generated by MongoDB.

The parallel between tables and collections can be drawn as both serve as containers for data storage. Similarly, documents and records represent individual instances of data within these containers. However, MongoDB's document-oriented approach offers more flexibility in terms of data modeling and schema design compared to the structured nature of tables and records in relational databases.

Overall, the concept of collections and documents in MongoDB provides a flexible and adaptable way to store and retrieve data, allowing developers to work with diverse data structures more efficiently.



## BSON format and data types

BSON, which stands for Binary JSON, is the binary representation format used by MongoDB to store and transmit data. It is designed to be efficient, compact, and fast to parse, making it well-suited for a document-based data model.

MongoDB supports various data types within BSON, allowing for the representation of diverse information within documents. Here are some commonly used data types supported by MongoDB:

1. Strings: MongoDB supports different types of strings, including regular strings (UTF-8 encoded), binary data, and UUIDs. Strings are used to store textual information.

Example:
```javascript
{
  "name": "John Doe",
  "email": "john@example.com",
  "bio": "Lorem ipsum dolor sit amet"
}
```

2. Numbers: MongoDB supports different numeric data types, such as integers (32-bit and 64-bit), floating-point numbers, and decimal data types for precise arithmetic operations. Numbers are used to store numerical values.

Example:
```javascript
{
  "age": 25,
  "price": 9.99,
  "quantity": 10
}
```

3. Booleans: MongoDB provides a Boolean data type for representing true or false values. Booleans are used for logical operations and conditional expressions.

Example:
```javascript
{
  "isAvailable": true,
  "isAdmin": false
}
```

4. Dates: MongoDB supports storing dates and timestamps. Dates are represented as a 64-bit integer value, which represents the number of milliseconds since the time of Unix (January 1, 1970). Dates are used for storing temporal information.

Example:
```javascript
{
  "createdAt": ISODate("2022-07-01T10:00:00Z"),
  "updatedAt": ISODate("2022-07-05T15:30:00Z")
}
```

5. Arrays: Arrays in MongoDB allow for the storage of multiple values within a single field. They can contain values of different data types and can be nested to create multi-dimensional arrays.

Example:
```javascript
{
  "tags": ["mongodb", "database", "nosql"],
  "scores": [80, 85, 90, 95]
}
```

6. Embedded Documents: MongoDB allows for the nesting of documents within other documents, enabling the creation of hierarchical and complex data structures. This feature is useful for representing relationships or grouping related data.

Example:
```javascript
{
  "name": "John Doe",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zipcode": "10001"
  }
}
```

In addition to these basic data types, BSON also supports more specialized data types, such as geospatial data, binary data, regular expressions, and timestamps.

By supporting a wide range of data types, BSON enables MongoDB to handle diverse data structures and accommodate the needs of various applications. It provides a flexible and efficient way to represent and store data within MongoDB's document-oriented model.


## Schema design principles and best practices


1. Scalability:

a) Plan for future growth:
- Start by connecting to your MongoDB server using the appropriate connection string.
- Enable sharding on your MongoDB deployment by configuring a sharded cluster.
- Create a sample collection:
  ```javascript
  use mydatabase;
  db.createCollection("mycollection");
  ```
- Enable sharding on the collection:
  ```javascript
  sh.enableSharding("mydatabase");
  sh.shardCollection("mydatabase.mycollection", { "_id": "hashed" });
  ```

b) Index optimization:
- Create an index on frequently queried fields:
  ```javascript
  db.mycollection.createIndex({ "productName": 1 });
  ```

2. Data Relationships:

a) Determine relationship types:
- Identify the relationships between different data entities in your application.
- For example, in a blogging platform, you have a one-to-many relationship between blog posts and comments.

b) Embedding vs. referencing:
- Choose the appropriate data modeling approach based on the nature of relationships.
- For example, consider embedding comments within a blog post document:
  ```javascript
  db.blogPosts.insertOne({
    "title": "My Blog Post",
    "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
    "comments": [
      {
        "author": "John",
        "text": "Great post!"
      },
      {
        "author": "Alice",
        "text": "I learned a lot from this."
      }
    ]
  });
  ```

3. Read/Write Patterns:

a) Understand data access patterns:
- Analyze the read and write patterns of your application.
- For example, determine if reading a blog post along with its comments is a common operation.

b) Data denormalization:
- Consider denormalizing data for improved read performance.
- For example, embed comments within a blog post document:
  ```javascript
  db.blogPosts.find({}, { "comments": 1 });
  ```

Remember to adapt these examples to your specific application requirements. Regularly monitor and optimize your MongoDB deployment based on real-world usage patterns to ensure effective schema design and performance.

## Embedded documents vs. referencing


1. Embedding Documents:

a) Improved Read Performance:
- Create a collection for orders and embed customer information within each order document:
  ```javascript
  db.orders.insertOne({
    "_id": ObjectId("6154e4cbe8d52b02409ae048"),
    "customer": {
      "name": "John Doe",
      "address": "123 Main St",
      "contact": "john.doe@example.com"
    },
    "orderItems": [
      { "productId": ObjectId("6154e510e8d52b02409ae049"), "quantity": 2 },
      { "productId": ObjectId("6154e522e8d52b02409ae04a"), "quantity": 1 }
    ]
  });
  ```

b) Data Duplication:
- Update an embedded customer's address in all related order documents:
  ```javascript
  db.orders.updateMany({ "customer.name": "John Doe" }, { $set: { "customer.address": "456 Elm St" } });
  ```

2. Referencing Documents:

a) Data Normalization:
- Create a separate collection for customers and reference customer IDs in the orders collection:
  ```javascript
  db.customers.insertOne({
    "_id": ObjectId("6154e5dce8d52b02409ae04b"),
    "name": "John Doe",
    "address": "123 Main St",
    "contact": "john.doe@example.com"
  });

  db.orders.insertOne({
    "_id": ObjectId("6154e4cbe8d52b02409ae048"),
    "customerId": ObjectId("6154e5dce8d52b02409ae04b"),
    "orderItems": [
      { "productId": ObjectId("6154e510e8d52b02409ae049"), "quantity": 2 },
      { "productId": ObjectId("6154e522e8d52b02409ae04a"), "quantity": 1 }
    ]
  });
  ```

b) Increased Query Complexity:
- Fetch an order along with its associated customer information using a join operation:
  ```javascript
  db.orders.aggregate([
    {
      $lookup: {
        from: "customers",
        localField: "customerId",
        foreignField: "_id",
        as: "customer"
      }
    },
    {
      $match: {
        "_id": ObjectId("6154e4cbe8d52b02409ae048")
      }
    }
  ]);
  ```

Remember to adapt these examples to your specific application requirements. Consider the nature of your data relationships, the frequency of data access, and the specific performance requirements when deciding between embedding and referencing. Regularly monitor and optimize your MongoDB deployment based on real-world usage patterns to ensure an effective schema design.

## One-to-one, one-to-many, and many-to-many relationships




In MongoDB, you can model different types of relationships between documents, including one-to-one, one-to-many, and many-to-many relationships. Let's explore each of these scenarios and demonstrate how to model them in MongoDB:

1. One-to-One Relationship:
   In a one-to-one relationship, each document is uniquely associated with another document. This type of relationship is represented by embedding the related data within the same document.

Example:
Let's consider a scenario where you have a "user" document and a "profile" document, where each user has one profile associated with them. You can model this relationship by embedding the profile information within the user document. The structure would look like:

```javascript
{
  "_id": "user1",
  "name": "John",
  "email": "john@example.com",
  "profile": {
    "dob": "1990-01-01",
    "gender": "Male",
    "address": "123 Main St"
  }
}
```

2. One-to-Many Relationship:
   In a one-to-many relationship, one document is associated with multiple related documents. This type of relationship is represented by embedding an array of related documents or by referencing the related documents.

Example:
Consider a scenario where you have a "category" document and multiple "product" documents within that category. You can model this relationship by either embedding the product documents within the category document as an array or by referencing the product documents using their unique identifiers.

Embedding:
```javascript
{
  "_id": "category1",
  "name": "Electronics",
  "products": [
    { "name": "TV", "price": 1000 },
    { "name": "Phone", "price": 800 }
  ]
}
```

Referencing:
```javascript
// category document
{
  "_id": "category1",
  "name": "Electronics"
}

// product documents
{
  "_id": "product1",
  "name": "TV",
  "price": 1000,
  "category_id": "category1"
}
{
  "_id": "product2",
  "name": "Phone",
  "price": 800,
  "category_id": "category1"
}
```

3. Many-to-Many Relationship:
   In a many-to-many relationship, multiple documents are connected to multiple other documents. This type of relationship is represented by referencing the related documents using arrays in both directions.

Example:
Let's say you have a "student" document and a "course" document, where each student can be enrolled in multiple courses, and each course can have multiple students. You can model this relationship by maintaining an array of student references in the course document and an array of course references in the student document.

```javascript
// student document
{
  "_id": "student1",
  "name": "Alice",
  "courses": ["course1", "course2"]
}

// course document
{
  "_id": "course1",
  "name": "Math",
  "students": ["student1", "student2"]
}
```

By using these modeling techniques, you can effectively represent and manage different types of relationships in MongoDB. The approach you choose depends on factors such as the nature of the relationship, the frequency of data access, and the performance requirements of your application.



